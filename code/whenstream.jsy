import {whenmap_watch} from './whenmap_watch.jsy'

export async function * whenstream(when_db, opt_ctx={}) ::
  var _dp_update, _cache = new Map()

  function on_update(key, value) ::
    let prev = _cache.get(key)
    if prev===undefined && !_cache.has(key) ::
      //First assignment; avoid re-triggering update
      _cache.set(key, value)
    else if value !== prev ::
      //Subsequent assignment; do triggering update
      _cache.set(key, value)
      _dp_update.resolve(true) // trigger composite update
    else :: //Identical assignment; avoid re-triggering update


  // wrap when_db in a watch observer
  when_db = whenmap_watch @ when_db, @{}
    __proto__: opt_ctx, on_update

  let when_tgt = opt_ctx.with_whenmap
    ? opt_ctx.with_whenmap(when_db) // allow wrapping the when_db; e.g. as a Proxy()
    : when_db // or passthrough

  const {signal, pre_tick, tick, post_tick} = opt_ctx
  while ! signal?.aborted ::
    //some dependency updated
    await _dp_update?.promise

    // wait throttled; e.g. requestAnimationFrame
    ; pre_tick && await pre_tick()

    //reset watcher
    _dp_update = Promise.withResolvers()

    ; tick && await tick()

    // return when_tgt because something changed
    yield when_tgt

    ; post_tick && await post_tick()


